/** @page apiFilesC C Language Support

@section apiFilesC_filesGenerated Files Generated

For the C language, five files are generated by @ref buildToolsifgen from the component interface file:

 - <b>client interface header file (interface.h)</b> - C definitions for the interface. This file should be
included by any C source files that want to use the interface.

 - <b>server header file (server.h) </b> - C definitions for the server interface. There is some
duplication between this file and the interface file, but it also contains definitions that
are not part of the public client interface. This file should be included by any C source files that want to implement the interface.

 - <b>local header file (local.h)</b> - local header file provides common definitions for the client and server implementations.
This file should only be included by the client and server implementation files.

 - <b>client implementation file (client.c) </b> - implements all of the interface functions.  These functions handle the details
of sending messages to the server, and processing the responses.

 - <b>server implementation file (server.c)</b> - implements handlers for all the interface functions.  These handlers receive
the message from the client side, call the corresponding real implementation of the function,
and generate any responses back to the client side.

@note Client and server implementation files are provided to support client/server IPC
implementations.


@section apiFilesC_handlerParm Handler Parameters in C

A handler parameter can be used in both events and regular functions.
This is how a handler parameter for a function in an interface file is mapped
to actual C definitions (based on the @ref apiFilesC_sampleAPI).

@code
FUNCTION int32 UseCallback
(
    uint32 someParm IN,
    TestAHandler handler
);
@endcode

This results in the function definition:

@code
int32_t UseCallback
(
    uint32_t someParm,
    TestAHandlerFunc_t handlerPtr,
    void* contextPtr
);
@endcode

A @c contextPtr parameter has been automatically added to the definition of the function.
This @c contextPtr will be passed back to the specified handler function when it is invoked.
If the @c contextPtr is not needed, then NULL can be used.


@section apiFilesC_event Events in C

This is how an event in an interface file is mapped
to actual C definitions (based on the @ref apiFilesC_sampleAPI).

@code
EVENT TestA
(
    uint32 data,
    TestAHandler myHandler
);
@endcode

This results in one type definition and two function definitions:

@code
typedef struct TestAHandler* TestAHandlerRef_t;

TestAHandlerRef_t AddTestAHandler
(
    uint32_t data,
    TestAHandlerFunc_t myHandlerPtr,
    void* contextPtr
);

void RemoveTestAHandler
(
    TestAHandlerRef_t addHandlerRef
);
@endcode

The parameters from the event definition are used in the ADD_HANDLER function. This is used
to register the given handler for events.  The REMOVE_HANDLER function does not take any
additional parameters, other than the reference returned by the ADD_HANDLER function.

A @c contextPtr parameter has been automatically added to the definition of the ADD_HANDLER
function.  The @c contextPtr passed to the ADD_HANDLER function, will be passed back to the
registered handler function.  If the @c contextPtr is not needed, then NULL can be used.


@section apiFilesC_handler Handlers in C

This is how a handler in an interface file is mapped
to actual C definitions (based on the @ref apiFilesC_sampleAPI):

@code
HANDLER TestAHandler
(
    int32 x
);
@endcode

This results in a type definition for the handler function pointer:

@code
typedef void (*TestAHandlerFunc_t)
(
    int32_t x,
    void* contextPtr
);
@endcode

A @c contextPtr parameter has been automatically added to the definition of the handler function
pointer. The @c contextPtr passed to a regular function or ADD_HANDLER function (see section
@ref apiFilesC_handlerParm or @ref apiFilesC_event, respectively) will be
passed back to the handler function. If the @c contextPtr is not needed, then NULL can be used.


@section apiFilesC_client Client-specific Functions

These are client-specific functions:

@code
void ConnectService
(
    void
);

void DisconnectService
(
    void
);
@endcode

To use a service, a client must connect to the server using @c ConnectService().  This
connection is only created for the current thread. Other threads must also call ConnectService()
to use the service.

For the main thread, @c ConnectService() is usually automatically called when the client app is
initialized. Disable this by using the .cdef provides @ref defFilesCdef_providesApiManualStart.

If a client app uses multiple services, multiple @c ConnectService() functions
need to be called; each function uses an appropriate prefix to distinguish these
clients. If multiple client apps are used, each app must be initialized
separately, using the appropriate ConnectService() function.

The DisconnectService() function closes a connection to the server.  It only
closes the current thread connection; it must be called separately for each
thread using a service. If a thread wants to use the service again, it must call
ConnectService() to re-connect. When the app exits, all connections for all threads
are automatically closed. A thread only needs to use DisconnectService() when it
wants to disconnect from a service while the app is still running (e.g., no longer needs
the service so it can conserve resources).

@section apiFilesC_server Server-specific Functions

These are server-specific functions:

@code
le_msg_ServiceRef_t GetServiceRef
(
    void
);

le_msg_SessionRef_t GetClientSessionRef
(
    void
);

void AdvertiseService
(
    void
);
@endcode

To provide a service, the server must advertise the service to any interested clients using
@c AdvertiseService(). This is usually automatically called during the initialization of the
server daemon. This can be disabled using the .cdef provides @ref defFilesCdef_providesApiManualStart.

If a server provides multiple services, multiple @c AdvertiseService() functions
need to be called; each function will have an appropriate prefix to distinguish each service.

The @c GetServiceRef() function is used to get the server session reference for the current
service. It's required if the server uses any of the server-specific @ref c_messaging functions
for this service.

For example, @ref le_msg_AddServiceCloseHandler can be used by the server to register a close
handler whenever a client closes its connection. This may be needed to cleanup client specific
data maintained by the server.

@c GetClientSessionRef() function is used to get the client session reference for the current
service. This client session is only valid while executing the server-side function that
implements an interface function.  Once this server-side function returns, the client session
can no longer be retrieved. @c GetClientSessionRef() is needed if the server wants to call
any of the client-specific @ref c_messaging functions for this service.

For example, @ref le_msg_GetClientUserId() can be used by the server to determine the UserId of
the client using the service, which allows the server to perform any necessary UserId based
authentication.

@section apiFilesC_asyncServer Asynchronous Server

There are two alternatives to implement the server-side functionality.

The default case is where each server-side function has the same interface as the client-side
function. The server-side function takes the IN parameters, and returns the OUT parameters and
function result when the function exits.

In the async-server case, the server-side function doesn't necessarily return the OUT parameters
and function result when it exits.  Instead, there's a separate @c Respond function for each
server-side function. The OUT parameters and function result are returned by passing these values
to the @c Respond function. The @c Respond function can be called at any time, normally after the
server-side function has exited.

Regardless of how the server-side functions are implemented, the client-side function waits until
the OUT parameters and function result are returned.

The async-server functionality is not enabled by default.
Enable it by using the .cdef provides @ref defFilesCdef_providesApiAsync.


@section apiFilesC_sendFd Sending File Descriptors

If a file descriptor is sent over the Legato IPC, the underlying messaging infrastructure would
close the file descriptor.  Therefore, after the file descriptor is passed as an "IN parameter" to a
function that uses Legato IPC, the file descriptor should not be explicitly closed. If the file
descriptor is needed after calling such function, it should be duplicated before being passed to the
function.

See the "file" type in @ref apiFilesSyntax_types.

See @ref c_messagingSendingFileDescriptors for more detail.


@section apiFilesC_sampleAPI API File Sample Output

Here's the generated client interface header file for the defn.api file from @ref apiFilesC_sampleAPI

@verbinclude defn_interface.h

Here's the generated client interface header file for the common.api file from @ref apiFilesC_sampleAPI

@verbinclude common_interface.h

Here's the generated client interface header file for the example.api file from @ref apiFilesC_sampleAPI

@verbinclude example_interface.h

<HR>

Copyright (C) Sierra Wireless Inc.

**/
